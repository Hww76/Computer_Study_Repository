# Computer Study Repository
学习计算机科学与技术中个人编写的各种程序的保存仓库

# TODO List
1. [Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN) 第一次通关(24/9/25),以后每个月通关一次，直至熟练，在下方打卡。
2. 学习Rust语言 完成时间：
3. 学完OS导论部分 完成时间：
4. RISC-V处理器的指令集和部分特权操作
5. RISC-V汇编语言

# 2024年
## [9月](./log/2024-9.md)

## 10月
10/1
* 完成rust课程48-57题

10/2
* Qemu模拟器
    * qemu-system-riscv64虚拟化的是基于riscv64指令集架构的主机，下面是它的配置。
    * -machine virt：设置设备平台为virt(待探究)
    * -nographic：无图形化界面
    * -bios：选择引导加载程序(bootloader)
    * -device：loader属性可以把宿主机的一个文件放入Qemu模拟的主机中的物理内存，file指出文件路径，addr指出存放的位置。
    ```
    qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
    ```
* Qemu启动流程
    1. 第一个阶段由固化在 Qemu 内的一小段汇编程序负责。
    主要工作：将必要的文件载入到 Qemu 物理内存，Qemu CPU 的程序计数器（PC）会被初始化为 0x1000 ，执行的第一条指令位于物理地址 0x1000 ，接下来它将执行数条指令并跳转到物理地址 0x80000000 对应的指令处并进入第二阶段。
    2. 第二个阶段由 bootloader 负责。
    主要工作：bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 os.bin
    3. 第三个阶段则由内核镜像负责。
* 程序内存布局
    1. .text：存放程序的所有汇编代码。
    2. .rodata：存放只读的全局数据。
    3. .data：存放可修改的全局数据。
    4. .bss：保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零。
    5. heap：存放程序运行时动态分配的数据。
    6. stack：函数调用上下文的保存与恢复，每个函数作用域内的局部变量，它向低地址增长。
* 编译流程
    1. 编译器：源文件从某门高级编程语言转化为汇编语言。
    2. 汇编器：源文件中的文本格式的指令转化为机器码，得到二进制的目标文件。
    3. 链接器：所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。第一步：将来自不同目标文件的段在目标内存布局中重新排布。第二件事情是将符号替换为具体地址。
* 在Qemu上正确运行脚本流程：
    1. 通过链接脚本调整内核可执行文件的内存布局，使得被执行的第一条指令位于地址 0x80200000 处。
    2. 使得代码段地址低于其他段
    3. 丢掉可执行文件中的元数据，得到内核镜像(只有代码段和数据段)。
